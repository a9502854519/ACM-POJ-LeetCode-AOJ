我的想法比較複雜點，大部份的思考都是藉由排容原理完成的。
令dp[i][j][k] 表示利用第一個字串的前i個字元，與第二個字
串的前j個字元，組成第三個字串[1, k]部份的方法數。
以下為了方便，假設第一二三個字串分別為Ａ，Ｂ，Ｃ。
如果A[i] == C[k]，則對於A[i]而言，可以用或不用，B[j]同
理，可以分為
(1)A[i]放在C[k]
(2)B[j]放在C[k]
(3)兩個都不放在C[k]

初步的遞推式為：
　　　　　　　　dp[i][j][k] = dp[i - 1][j][k] 
                            + dp[i][j - 1][k] 
                            + dp[i - 1][j][k - 1] (if A[i] == C[k])
                            + dp[i][j - 1][k - 1] (if B[j] == C[k])
上述分別計算了(1) A[i]不放在C[k] 
              (2) B[j]不放在C[k]
              (3) A[i]放在C[k]
              (4) B[j]放在C[k]
其中(1) (2)　會重複計算, 有以下三種情形

(a) A[i] == C[k] && B[j] == C[k]
則范氏圖會長這樣：
 ___________________________
|                           |
|                           |
| A[i]不放在C[k]       _____|____________________
|                     |     |                    | 
|                     |     |                    |
|                     |     |   B[j]不放在C[k]   |
|_____________________|_____|                    |
                      |                          |
　　　　　　　　　　　|                          |
                      |__________________________|

(1) (2) 分別計算了兩個區塊各一次，而我們想要的是中間的交集部份(兩個
都不放在C[k])，因此要在左邊的區塊中減掉A[i]不放在C[k]且B[j]放在C[k]
的方法數：dp[i - 1][j - 1][k - 1]，對右邊的也同理：dp[i - 1][j - 1][k - 1]
然後還要再減掉中間的交集一次：dp[i - 1][j - 1][k]

接著，第二種情形為其中一個 == C[k]，假設為A[i]好了
(b) A[i] == C[k] && B[j] != C[k]
 _________________________
|                         |
|                         |
|     B[j]不放在C[k]      |
|                         |
|   ___________________   |        
|  |                   |  |
|  |                   |  |
|  |  A[i]不放在C[k]   |  |
|  |                   |  |
|  |___________________|  |
|_________________________|         

因此，要減掉B[k]不放在C[k]且A[i]放在C[k]的方法數：dp[i - 1][j - 1][k - 1]
還要減掉兩者皆不放在C[k]的方法數：dp[i - 1][j - 1][k]

(c) 兩者皆不等於C[k]
范氏圖就不畫了，兩個會完全重疊，需要減掉兩者皆不放在C[k]的方法數：dp[i - 1][j - 1][k]

至此，我們分析了所有會重複的情形。把該減掉的減掉就好。







