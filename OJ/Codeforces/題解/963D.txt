如果用字尾陣列的話，因為要用二分搜尋的關係，時間複雜度會
多個log(|s|)，不太OK。這裡借用一下別人的做法--用bitset。
bitset其實就是支援位元操作的vector<bool>。而在這題裡，可
以用26個bitset紀錄每種字母分別出現在哪些位置。對於輸入的
字串m，假設其開頭字母為a好了，我們就先取用紀錄a出現位置的
bitset，接著往下看第二個字母(假設為b)，我們會想知道有哪些
a後面是跟著b的，這裡只要取用紀錄b出現位置的bitset，往右移
一個位元，然後跟a的bitset做交集運算即可。如果某個a後面是跟
著b的，則該位元的1會被保留下來，反之會被交集運算給消掉。
